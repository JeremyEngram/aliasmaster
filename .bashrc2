# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

MYLLM="ggml-gpt4all-j-v1.3-groovy.malformed.b1.bin"

eval "$(register-python-argcomplete pipx)"

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we want color)
#case "$TERM" in
#    xterm-color|*-256color) color_prompt=yes;;
#esac



# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac



#text="Welcome To Project Omniscient aka Offensive-OSINT - $USER - pronounced and short-handed; spelled Omnisint is more than just a single tool, series of tools, or suite of tools geared towards digital forensics and private investigators. It is a hueurisitc, polymorphic artificial intelligence self-learning, adaptive positive-feedback-loop infrastructure framework with primarily python harded-coded base-line automation scripts that conver and exceed the three main branches of intelligence gathering - SigINT, HumanINT, and TechINT - branching off into the five main areas of applied sciences in digital foreniscs, System, Disk, Database, Network and File forensics analysis. While putting empathsis on the HUMAN adaptive aspect of SOCMINT or Social Media Intelligence Gathering and proactive skip-tracing.\n FOR MORE INFORMATION ON OFFENSIVE-OSIBT THE SYSTEM WILL OPEN A CONVERSATION WITH GORILLA - THE OFFICIAL SYSTEM HOST AI ASSISTANT." \n 

#for ((i=0; i<${#text}; i++)); do
#    echo -n "${text:i:1}"
#    sleep 0.04  # Adjust the sleep duration to control typing speed
#done; echo



# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias dir='dir --color=auto'
    alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# some more ls aliases
# alias ll='ls -alF'
# alias la='ls -A'
# alias l='ls -CF'


# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

alias syslog-alert='tail -f /var/log/syslog | grep --line-buffered "error" | while read line; do notify-send --urgency=low -i error "Syslog Error" "$line"; done'


# LOG ALL COMMANDS TO /VARLOG/COMMANDS
# export PROMPT_COMMAND='RETRN_VAL=$?;logger -p local6.debug "$(whoami) [$$]: $(history 1 | sed "s/^[ ]*[0-9]\+[ ]*//" ) [$RETRN_VAL]"'
export PROMPT_COMMAND='RETRN_VAL=$?;logger -p local6.debug "$(whoami) [$$]: $(history 1 | sed "s/^[ ]*[0-9]\+[ ]*//" )"'


# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bashrc_aliases ]; then
    . ~/.bashrc_aliases
fi

if [ -f ~/.bashrc_functions ]; then
    . ~/.bashrc_functions
fi

if [ -f ~/.bashrc_connectors ]; then
    . ~/.bashrc_connectors
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi


# JINA_CLI_BEGIN

## autocomplete
_jina() {
  COMPREPLY=()
  local word="${COMP_WORDS[COMP_CWORD]}"

  if [ "$COMP_CWORD" -eq 1 ]; then
    COMPREPLY=( $(compgen -W "$(jina commands)" -- "$word") )
  else
    local words=("${COMP_WORDS[@]}")
    unset words[0]
    unset words[$COMP_CWORD]
    local completions=$(jina completions "${words[@]}")
    COMPREPLY=( $(compgen -W "$completions" -- "$word") )
  fi
}

complete -F _jina jina

# session-wise fix
ulimit -n 4096
export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES

# default workspace for Executors

# JINA_CLI_END ############################################################################################## END ORIGINAL BASHRC FILE

# EXPORTS
export VM="/home/jeremy/VirtualBox_VMs"
export DATA="/home/jeremy/websites"
export BACKEND="/var/www/html/backend"
export SCRAPEFRAME="/var/www/html/scrapeframe"
export OMNILOG="/var/www/html/omnilog"

export BASHLY=""
export OCLIF=""

OPENAI_KEY="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"

# SIMPLE SET OF ALIASES
alias arm="sudo chmod +x"
alias implement="sudo apt install -y"
alias dropoff="sudo apt remove --purge -y"
alias blowoff="sudo apt autoremove; sudo apt clean"

alias mkvenv="python3 -m venv"

alias piplist="pip list"
alias piplistrm="pip list | awk '{print $1}' | xargs pip uninstall -y"
alias pipreqenvs="pip freeze > requirements.txt && pip uninstall -y -r requirements.txt"

alias pipuninstallall="pip uninstall -y -r <(pip freeze)"
alias pipenvuninstall="pipenv uninstall --all"

alias blowoffpypip="sudo apt remove python3-pip --purge"
alias blowoffpip="pip uninstall -y -r <(pip freeze)"
alias blowoffpipx="pipx list --include-injected | cut -f 1 -d ' ' | xargs pipx uninstall"
alias blowoffpip2="pip3 freeze > unins ; pip3 uninstall -y -r unins ; rm unins"
alias blowoffpip3="pip3 freeze --user | xargs pip3 uninstall -y"
alias blowoffvenv="virtualenv --clear MYENV"